import * as markedschema from "marked-schema";
import * as markedtypedschema from "typed-schema-markdown";
var fs = require("fs");
import { forEach } from "p-iteration";
import { SchemaType, SchemaClass, SchemaEnum } from "../../typed-schema-markdown/node_modules/typed-schema";
import { Schema } from "typed-schema";

export async function generateAsync() {

	// First find the top-level directory
	var relativeTopDir = findRelativeTopDirectory();

	await generateHostConfigAsync(relativeTopDir);

	await generateElementsAsync(relativeTopDir);
	
}

async function generateHostConfigAsync(relativeTopDir: string) {

	var schemaModel = await markedschema.buildModel({
		schema: relativeTopDir + "schemas/host-config.json",
		toc: relativeTopDir + "source/nodejs/adaptivecards-site/schema-hostconfig-toc.yml",
		rootDefinition: "AdaptiveCardConfig"
	});

	var finalContents = "# Host config";

	await forEach(schemaModel, async (root: any) => {
		await forEach(root.children, async (child: any) => {

			finalContents += "\n\n## " + child.name;

			finalContents += markedschema.generateMarkdown.createPropertiesSummary(child.properties, null, true, true, child.version);
		});
	});

	await writeFileAsync(relativeTopDir + "specs/HostConfig.md", finalContents);

}

async function generateElementsAsync(relativeTopDir: string) {

	var schemaModel = await markedtypedschema.buildModel({
		schema: relativeTopDir + "schemas/src",
		toc: relativeTopDir + "source/nodejs/adaptivecards-site/schema-explorer-toc.yml",
		rootDefinition: "AdaptiveCard",
		examplesPath: relativeTopDir + "samples/v1.*"
	});

	await forEach(schemaModel, async (root: any) => {
		await forEach(root.children, async (child: any) => {
			var type: SchemaClass = child.type;
			var markdown = markedtypedschema.createPropertiesSummary(type, null, true, true, child.version);

			markdown = "# " + child.name + "\n\n" + markdown;

			var endAutoGeneratedTag = "<!-- END AUTO-GENERATED -->";
			markdown = "<!-- AUTO-GENERATED: This section is auto-generated from schemas/adaptive-card.json. Do NOT add anything above this or edit anything inside, it MUST be the first thing in the document and will be overwritten. -->\n\n" + markdown + endAutoGeneratedTag;

			var fileName = relativeTopDir + "specs/elements/" + child.name + ".md";
			var finalFileContents;

			try {

				var data = await readFileAsync(fileName, "utf8");

				var endAutoGeneratedIndex = data.indexOf(endAutoGeneratedTag);
				if (endAutoGeneratedIndex === -1) {
					finalFileContents = markdown + "\n\n" + data;
				} else {
					endAutoGeneratedIndex += endAutoGeneratedTag.length;
					finalFileContents = markdown + data.substring(endAutoGeneratedIndex);
				}

			} catch (err) {

				// No existing file, add on the ## Rendering header
				finalFileContents = markdown + "\n\n## Rendering";

			}

			await writeFileAsync(fileName, finalFileContents);
		});

		// Generate enum files
		var schema:Schema = root.schema;
		schema.typeDictionary.forEach(type => {
			if (type instanceof SchemaEnum) {
				var markdown = markedtypedschema.createEnumSummary(type);

				markdown = "# " + type.type + " enum\n\n" + markdown;

				var endAutoGeneratedTag = "<!-- END AUTO-GENERATED -->";
				markdown = "<!-- AUTO-GENERATED: This section is auto-generated from schemas/adaptive-card.json. Do NOT add anything above this or edit anything inside, it MUST be the first thing in the document and will be overwritten. -->\n\n" + markdown + endAutoGeneratedTag;

				var fileName = relativeTopDir + "specs/enums/" + type.type + ".md";
				var finalFileContents;

				try {

					var data = readFile(fileName, "utf8");

					var endAutoGeneratedIndex = data.indexOf(endAutoGeneratedTag);
					if (endAutoGeneratedIndex === -1) {
						finalFileContents = markdown + "\n\n" + data;
					} else {
						endAutoGeneratedIndex += endAutoGeneratedTag.length;
						finalFileContents = markdown + data.substring(endAutoGeneratedIndex);
					}

				} catch (err) {

					// No existing file, add on the ## Rendering header
					finalFileContents = markdown + "\n\n## Rendering";

				}

				writeFile(fileName, finalFileContents);
			}
		});
	});

}

function readFileAsync(fileName: string, encoding: string) : Promise<string> {
	return new Promise(function(resolve, reject) {
		fs.readFile(fileName, encoding, (err, data) => {
			if (err) {
				reject(err);
			} else {
				resolve(data);
			}
		});
	});
}

function readFile(fileName: string, encoding: string) : string {
	return fs.readFileSync(fileName, encoding);
}

function writeFileAsync(fileName: string, contents: string) : Promise<void> {
	return new Promise(function(resolve, reject) {
		fs.writeFile(fileName, contents, (err) => {
			if (err) {
				reject(err);
			} else {
				resolve();
			}
		})
	});
}

function writeFile(fileName: string, contents: string) : void {
	fs.writeFileSync(fileName, contents);
}

function findRelativeTopDirectory(backLevels?: string) : string {
	if (!backLevels) {
		backLevels = "";
	}

	try {
		fs.accessSync(backLevels + "schemas/adaptive-card.json");
		return backLevels;
	} catch (err) {
		if (backLevels.length > 50) {
			throw new Error("Couldn't find. Backlevels were: " + backLevels);
		} else {
			return findRelativeTopDirectory("../" + backLevels);
		}
	}
}